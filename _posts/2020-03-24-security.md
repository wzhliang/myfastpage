---
toc: true
layout: post
description: My Precious Notes on Security
categories: [markdown]
title: On Security
---
# Cryptology
## Symetric encryption
* Alice and Bob have to have the same secrete key
* also called secrete key cryptography
* cipher can be either block type or stream type
* ciphers
    * DES, 3DES,
    * RC2, RC4
    * ...
* AES (Advanced Encryption Standard)

## Public Key Encryption (Asymetric)
* Bob has a pair of keys, a private one and a public one.
* The pubic one can be shared to the whole world.
* Any message that's encrypted with the public key can *only* be decrypted
  with the matching private key.
* the two keys are mathematically linked
* so: public key is for encryption, private key is for decryption
* frequently (but not necessarily), the keys are interchangeable, in the sense
  that if key A encrypts a message, then B can decrypt it, and if key B encrypts
  a message, then key A can decrypt it. While common, this property is not
  essential to asymmetric encryption.
* ciphers
    * RSA
    * Diffie Hellman
* mathematical
    * based on drapdoor one-way-function
    * [csci-467](http://cs.stfx.ca/~ltyang/csci-467/lecture-slides/ch-10.pp)
    * OWF is a function that's very hard to reverse
    * with a trapdoor, it becomes easy
* 解决了两个关键的问题：证明我是谁，信息加密

## Message digest algorithm
* a message digest is computed by a hash function, which is a transformation that meets two criteria:
    1. The hash function must be one way. It must not be possible to reverse the
       function to find the message corresponding to a particular message digest,
       other than by testing all possible messages.
    2. It must be computationally infeasible to find two messages that hash to the
       same digest.

## Encrypting vs Signing
* when encrypting, you use their public key to write message and they use their private key to read it.
* when signing, you use your **private key** to write message's signature, and they
  use your public key to check if it's really yours.
    * often the signing is done on a message digest(hash) rather than the message
      itself

### Signing
<img alt=ibm src="https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.1.0/com.ibm.mq.doc/sy10520a.gif" width="75%">

## Cipher
* or cypher is the encrypting/decrypting algorithm
* currently AES is considered a strong cipher.
* triple DES or RC4 are weak.
* elliptic curve cryptography
    * [wikipedia](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography)
* a cipher suit includes algorithms for:
    * authentication
    * encryption
    * MAC (message authentication code)
    * key exchange
* [cipher suit](http://www.jscape.com/blog/cipher-suites)

## XOR
* XOR is used quite often in encryption algorithms
* XOR cipher
    * `(message) XOR key -> (encrypted message)`
    * `(encrypted message) XOR key -> (message)`
    * known as _one time pad_ or (OTP) for short
    * impossible to crack
    * impractical to use keys that are the same length as the message body
* [dev.to](https://dev.to/wagslane/why-is-exclusive-or-xor-important-in-cryptography-e7b)
    * **Why is Exclusive Or (XOR) Important in Cryptography?**

### XOR Truth table
<img src="http://borlandc.pek3b.qingstor.com/security/xor-binary-operation.png" width="35%">


# TLS
* build on top of TCP to make the upper layer security transparent
* two goals: confidentiality and authentication.
* for confidentiality, a shared key is established.
* for authentication, public key technology is used for proving ownership of certificates.
* provides
    * authentication, when I'm connecting to google.com, am I actually
      connecting to google.com?
    * encryption
    * integrity, message is not tempered with during transition
    * key exchange

## Versions
* TLS 1.0 is SSL 3.1
* TLS 1.2
* TLS 1.3. working draft
    * one less handshake, client sends its key with the first HELLO message
    * [twitter](https://twitter.com/colmmacc/status/978430840198742016)


## Concepts
* session key: end result of the handshake. A key for symmetric cipher.
* client random: 32 bytes sequence choosed by the client. Also call nonce. 
* server random: same as above but generated by the server.
* pre-master secreted: 48 bytes blob of data. Simply put:
    - client random + server random + pre-master secrete = session key
* cipher suit: combination of algorithms making up the TLS connection
    - key establishment
    - authentication (certificate type)
    - confidentiality (symmetric cipher)
    - integrity (hash)
* AES128-SHA as a cipher suit example
    - key establishment (RSA)
    - authentication (RSA)
    - confidentiality (128 bit AES)
    - integrity (160 bit SHA1)

## Certificates
* purpose is to assuring the identity of websites.
* binds domain names to server names, and company names to locations.
* a TLS certificate is a kind of X.509 certificate
* a certificate file include public key of the owner.
* a certificate has a corresponding private key
* Certificates are provided by CA (certification authority), which is some
  well known certificate issuer
    * certs can also be generated easily with the `openssl` suit, this is called
      self-signing
* when a web server (say google) sends you its certificate, it also tell you who
  signed it (GeoTrust). On the system where openssl is installed, there is
  already a list of CAs installed, and GeoTrust is one of them. Using GeoTrust's
  public key, we can verify that google's certificate is valid.
    * [prove](https://www.archlinux.org/packages/core/any/ca-certificates/)
* a root certificate identifies the root CA
    * it's self-signed
* any certificate that sits between the SSL Certificate and the Root Certificate
  is called a chain or Intermediate Certificate. 

### X509 naming schema
* same standard as LDAP
* CN: common name
* names:
    * C: contry
    * L: location
    * O: organization
    * OU: organization unit

### File Format
* normally (or most of the world) uses PEM format, which is a textual file. 
* DER is a binary format that's used by M$
* convertion can be done with `openssl x509 -in cacert.pem -out cacert.cer -outform DER`

### CSR
<img alt=CSR src="http://pki-tutorial.readthedocs.io/en/latest/_images/PKIProcess.png" width="55%">

### What's Inside
<img alt=content src="images/certificate.png" width="55%">

### Chain Of Trust
<img src="http://borlandc.pek3b.qingstor.com/security/pki-chain.jpg" width="75%">


## TLS Handshake
* **client hello**. client sends:
    - client random
    - cipher suit supported
    - version of SSL/TLS it's using
* **server hello**. server sends:
    - server random
    - the decided cipher suit
    - server's certificate
* client key exchange
    - Client:
        - verify server's certificate (e.g. checking signature - decrypting with root cert)
        - generate random pre-master secrete
        - encrypt secrete with server's public key
        - send encrypted data to server
    - Server:
        - decrypt message with its own private key
    - Both: having client random, server random and pre-master secrete, a session key
      (same on both side) can be calculated.
* session start with symmetric cipher

### Flow
<img alt=IBM src="https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.1.0/com.ibm.mq.doc/sy10660a.gif" width="55%">

### Flow with More Detail
<img alg=better-flow src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg/1430px-SSL_handshake_with_two_way_authentication_with_certificates.svg.png" width="75%">

## Self Signed
    openssl req \
     -newkey rsa:2048 -nodes -keyout domain.key \
     -x509 -days 365 -out domain.crt

* `-keyout` specifies private key
* `-out` specifies TLS certificate
* will be asked about FQDN or IP address
* [android documentation](https://developer.android.com/training/articles/security-ssl.html#SelfSigned)
* `sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain site.crt`
    * adding self signed certificate on MacOS

## SNI
* service name indication
* allows multiple certs to be issued to a single IP port pair
    * [comodo](https://support.comodo.com/index.php?/Knowledgebase/Article/View/1120/38/what-is-sni-and-how-it-works)


# REST API
* use API keys instead of user/password pair.
    - keys are much longer so securer
    - password reset can cause trouble if user/password pair is used
* use opaque ids instead of increasing numbers like '1234' 
* avoid sessions in REST API for better performance and scalability
* one way of implementing this is to use http server's TLS ability and leave application
  server out of it.


# Options for Securing REST API
## Basic Authentication + TLS
* easy to implement but not as secure as other options
* has to be enforced by client and server. If client can choose to use inscecure channel
  and server allows it, it's broken.

## OAuth 1.0a
* Widely used so a lot of libraries supports it.
* Very secure.

## OAuth 2
* Not as many library supports this.
* Less secure than OAuth 1.0a but supposedly simpler.
* TLS required.
* Roles
    * Resource Owner/User
    * Client
    * Resource Server
    * Authorization server
* [medium](https://medium.com/@darutk/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb)
* [do](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)

## OAuth 2 Sequence Diagram
<img src="http://borlandc.pek3b.qingstor.com/security/oauth2flow.png" width="55%">

## OAuth 2 Flow
<img src="http://borlandc.pek3b.qingstor.com/security/oauthflow.png" width="85%">

## Normal OAuth Workflow (Simplified)
1. The user first initiates a request on the Client website.
1. The Client will then send an Access Token to an API Gateway.
1. The API Gateway will then pass the Access Token to the Authorization Server (the OAuth server).
1. The Authorization Server verifies that the Access Token is correct, and sends an JWT Access Token to the API Gateway.
1. The API Gateway then passes the JWT Access Token to a microservice which will need to act as a trigger each month for a continuous job. We’ll call this Trigger Savings API.
1. The job is then inserted into a Queue, which triggers a second microservice that moves money into the account. We’ll call this the Do Savings API.
1. The Queue is reset, and Step 6 is repeated when the correct time has elapsed.

from [here](https://nordicapis.com/how-to-handle-batch-processing-with-oauth-2-0/)

## OpenID Connect
* based on OAuth 2.0
    * NOT OpenID!!!
* REST-based
* SAML??


# Commercial Company
* [stormpath](https://stormpath.com)


# cfssl
* `cfssl print-defaults <csr|config>`
    * handy command to create templates for CSR and signing config file


# Terms
* PKI - Public Key Infrastructure
* CSR - Certificate Signing Request
    * a request to CA for issuing a certificate
    * content include:
        * host names, IP addresses
        * CN `foo.bar.whatever`
        * key: algorithm and size
* HTTPS - HTTP Over SSL
* PKCS #12 - private key format, also named `.p12`
    * alternative to PEM format private key
* CN - Common Name
    * for web server, this is the FQDN
    * CN is only evaluated if subjectAltName is not present and only for compatibility with old, non-compliant software. 
        * [here](CN is only evaluated if subjectAltName is not present and only for compatibility with old, non-compliant software. )
* CA - certificate authority
    * Root CA
    * Intermediate CA - below root CA but do not issue user certs
    * Signing CA - issuer of user certs
* RA - registration authority
* TLS - transport layer security
    * accepts request
    * authenticate the entity that makes the request
* X.509 - a standard definition of public key certificate
    * defined in RFC 5280
* ACME - Automatic Certificate Management Environment
    * designed for and used by Let's encrypt
* PEM - Privacy Enhanced Mail 
    * basically a base64 method for representing binary DES data


# CLI
* `openssl x509 -text -noout -in apiserver.crt`
    * print information on certificate, like CN, IP
* `openssl s_client -showcerts -connect google.com:443 </dev/null`
    * show certification
* `openssl x509 -in google_com.crt -noout -text`
    * decode a crt?
* `man x509` or `man openssl-x509`
* `man s_client` or `man openssl-s_client`
* `openssl genrsa ...`
    * generate RSA private key
* `openssl req ...`
    * geneate certificate request
* `openssl genrsa -out private.pem 1024`
    * This creates a key file called private.pem that uses 1024 bits. This file actually have **both** the private and public keys 
    * `openssl rsa -in private.pem -outform PEM -pubout -out public.pem` extracts public key
    * The NIST recommends 2048-bit keys for RSA (wikipedia)
* [rieta](https://rietta.com/blog/openssl-generating-rsa-key-from-command/)
    * openssl commands
    * what private key and public key look like


# Links
* [slideshare](http://www.slideshare.net/stormpath/secure-your-rest-api-the-right-way)
    - secure your REST API the right way
    - lot of jargons, not easy to understand
    - [companion article](https://stormpath.com/blog/secure-your-rest-api-right-way/)
* [so solution](http://stackoverflow.com/questions/25218903/how-are-people-managing-authentication-in-go/27470944#27470944)
    - managing auth in Go
    - somebody posted rather detailed solution
* [stackexchange](http://security.stackexchange.com/questions/20803/how-does-ssl-tls-work)
    - how does TLS work
* [debug](http://noxxi.de/research/ssl-debugging.html)
* [do](https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs)
    - working with certificate, etc
    - what is CSR, how to generate it
* [do](https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-16-04)
    - how to create a self-signed certifcate
    - generate SSL certificate
    - format conversion
* [so huge question](http://stackoverflow.com/questions/15051712/how-to-do-authentication-with-a-rest-api-right-browser-native-clients)
* [oreily](https://www.oreilly.com/learning/https-is-coming-are-you-prepared?imm_mid=0f114b&cmp=em-webops-na-na-newsltr_20170421)
    - video
* [tls-gen](https://github.com/michaelklishin/tls-gen)
    - Python based tool for generating self-signed CA certification and keys
* [rabbitmq](https://www.rabbitmq.com/ssl.html)
    - enable TLS for rabbimq
* [gfi](http://manuals.gfi.com/en/kerio/connect/content/server-configuration/ssl-certificates/adding-trusted-root-certificates-to-the-server-1605.html)
    - adding trusted root on various OSes
* [confusion](https://support.ssl.com/Knowledgebase/Article/View/19/0/der-vs-crt-vs-cer-vs-pem-certificates-and-how-to-convert-them)
    - DER, CRT, CER, PEM
    - PEM and DER are encoding format
    - PEM can be used for a lot of different types: certificate, key, CSR, etc
    - CRT, CER are file extensions indicating the nature of the file
* [readthedock](http://pki-tutorial.readthedocs.io/en/latest/index.html)
    - OpenSSL PKI tutorial 
* [jd](http://www.infoq.com/cn/articles/jingdong-financial-private-cloud-https-practices#)
    - JD https optimization
* [slidesshare](https://www.slideshare.net/smaret/introduction-to-pki-technology)
    - 192 pages of slides introducing PKI
* [cfssl](https://blog.cloudflare.com/introducing-cfssl/)
    - intro to cfssl
* [technedigitale](https://technedigitale.com/archives/639)
    - on cfssl
    - creates root CA, intemediate CA and end device certs
* [k8s](https://kubernetes.io/docs/concepts/cluster-administration/certificates/)
    - various way to setup a self-signed PKI
* [oschina](https://my.oschina.net/kimver/blog/1634575#comment-list)
    * let's encrypt 泛域名
* [ulfheim](https://tls.ulfheim.net)
    * wonderfully illustrated TLS process
    * a lot of detail
* [lj, x509, pki](https://www.linuxjournal.com/content/understanding-public-key-infrastructure-and-x509-certificates)
    * Understanding Public Key Infrastructure and X.509 Certificates
* [history, one](https://onezero.medium.com/the-untold-story-of-the-man-that-made-mainstream-encryption-possible-231c749d5005)
    * **The Untold Story of the Man That Made Mainstream Encryption Possible**
    * White Diffie
* [ssh, online, tool](https://8gwifi.org/sshfunctions.jsp)
    * **Generate SSH Keys Online**
